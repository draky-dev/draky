#!/usr/bin/env bats

bats_require_minimum_version 1.9.0

if [ -z "${TESTUSER_NAME}" ]; then
  echo "TESTUSER_NAME was supposed to be provided by the image, but is not available!"
  exit 1
fi

if [ -z "${TESTUSER_UID}" ]; then
  echo "TESTUSER_UID was supposed to be provided by the image, but is not available!"
  exit 1
fi

TESTUSER_HOME="/home/$TESTUSER_NAME"
TEST_PROJECT_PATH="/home/${TESTUSER_NAME}/draky-test-environment"
TEST_PROJECT_NAME=test-project
ENV_PATH="${TEST_PROJECT_PATH}/.draky/env/dev"
RECIPE_PATH="${ENV_PATH}/docker-compose.recipe.yml"
COMPOSE_PATH="${ENV_PATH}/docker-compose.yml"
HOST_STORAGE_PATH="/home/${TESTUSER_NAME}/storage"

setup() {
  mkdir -p "${TEST_PROJECT_PATH}"
  mkdir -p "${HOST_STORAGE_PATH}"
}

teardown() {
  ${DRAKY} env down
  rm -r "${TEST_PROJECT_PATH}"
  rm -r "${HOST_STORAGE_PATH}"
}

_initialize_test_environment() {
  cd "${TEST_PROJECT_PATH}" || exit 1
  printf "%s\n0\n" "${TEST_PROJECT_NAME}" | ${DRAKY} env init
}

@test "Environment initialization (default template)" {
  _initialize_test_environment
  [ -d "${TEST_PROJECT_PATH}/.draky" ]
}

@test "Environment initialization (custom template)" {
  TEST_TEMPLATE_FILE=test-template-file
  createCustomTemplate() {
    local TEST_TEMPLATE_PATH="$TESTUSER_HOME/.draky/templates/${1}"
    mkdir -p "${TEST_TEMPLATE_PATH}"
    touch "${TEST_TEMPLATE_PATH}/${TEST_TEMPLATE_FILE}"
    cat > "${TEST_TEMPLATE_PATH}/template.dk.yml" << EOF
id: ${1}
EOF
  }
  createCustomTemplate test-template
  cd "$TEST_PROJECT_PATH"
  printf "test-project\n1\n" | ${DRAKY} env init
  [ -f "${TEST_PROJECT_PATH}/.draky/${TEST_TEMPLATE_FILE}" ]
}

@test "Context switching" {
  _initialize_test_environment
  cd /
  run ${DRAKY} -h
  [[ "$output" == *"Leaving the context: '${TEST_PROJECT_PATH}/.draky'"* ]]
  [[ "$output" == *"Entering the context: 'None'."* ]]
}

@test "Built-in commands default help" {

  testDefaultHelp() {
    run "$@"
    [[ "$output" == *"show this help message and exit"* ]]
  }

  testDefaultHelp "${DRAKY}" core
  testDefaultHelp "${DRAKY}" env

  _initialize_test_environment
  testDefaultHelp "${DRAKY}" env debug
}

coreVarsOutputted() {
  [[ "$output" == *"DRAKY_VERSION"* ]]
  [[ "$output" == *"DRAKY_HOST_UID"* ]]
  [[ "$output" == *"DRAKY_HOST_GID"* ]]
  [[ "$output" == *"DRAKY_PROJECT_CONFIG_ROOT"* ]]
  [[ "$output" == *"DRAKY_PROJECT_ROOT"* ]]
  [[ "$output" == *"DRAKY_HOST_IP"* ]]
  [[ "$output" == *"DRAKY_PATH_ADDONS"* ]]
  [[ "$output" == *"DRAKY_PROJECT_ID"* ]]
  [[ "$output" == *"DRAKY_ENVIRONMENT"* ]]
}

@test "Core vars in debug" {
  _initialize_test_environment
  run "${DRAKY}" env debug vars
  coreVarsOutputted
}

@test "Core vars in .env file" {
  _initialize_test_environment
  "${DRAKY}" env build
  run cat $ENV_PATH/.env
  coreVarsOutputted
}

@test ".env file is marked as autogenerated by a comment" {
    _initialize_test_environment
  "${DRAKY}" env build
  run cat $ENV_PATH/.env
  [[ "$output" == *"# This file is autogenerated"* ]]
}

@test "Custom vars in debug" {
  _initialize_test_environment
  cat > $TEST_PROJECT_PATH/.draky/test.dk.yml << EOF
variables:
  TEST_VAR: test1
EOF
  run ${DRAKY} env debug vars
  [[ "$output" == *"TEST_VAR"* ]]
  [[ "$output" == *"test1"* ]]
}

@test "Custom vars in .env file" {
  _initialize_test_environment
  cat > $TEST_PROJECT_PATH/.draky/test.dk.yml << EOF
variables:
  TEST_VAR: test1
EOF
  "${DRAKY}" env build
  run cat $ENV_PATH/.env
  [[ "$output" == *"TEST_VAR"* ]]
  [[ "$output" == *"test1"* ]]
}

@test "Config dependencies" {
  _initialize_test_environment
    createConfigFile() {
    cat > "$TEST_PROJECT_PATH/.draky/${1}.dk.yml" << EOF
id: ${1}
variables:
  TEST_VAR: ${2}
EOF
  }
  createConfigFileWithDependency() {
    cat > "$TEST_PROJECT_PATH/.draky/${1}.dk.yml" << EOF
id: ${1}
variables:
  TEST_VAR: ${2}
dependencies:
  - ${3}
EOF
  }
  createConfigFile test1 value1
  createConfigFileWithDependency test2 value2 test1
  run ${DRAKY} env debug vars
  [[ "$output" == *"TEST_VAR"* ]]
  [[ "$output" == *"value2"* ]]
  createConfigFile test2 value2
  createConfigFileWithDependency test1 value1 test2
  run ${DRAKY} env debug vars
  [[ "$output" == *"TEST_VAR"* ]]
  [[ "$output" == *"value1"* ]]
}

@test "Config dependencies unmet" {
  _initialize_test_environment
  createConfigFileWithDependency() {
    cat > "$TEST_PROJECT_PATH/.draky/${1}.dk.yml" << EOF
id: ${1}
dependencies:
  - ${2}
EOF
  }

  createConfigFileWithDependency test1 nonexistentdependency
  run ${DRAKY}
  [[ "$status" == 1 ]]
  [[ "$output" == *"nonexistentdependency"* ]]
}

@test "Config dependencies cyclic" {
  _initialize_test_environment
  createConfigFileWithDependency() {
    cat > "$TEST_PROJECT_PATH/.draky/${1}.dk.yml" << EOF
id: ${1}
dependencies:
  - ${2}
EOF
  }
  createConfigFileWithDependency test1 test2
  createConfigFileWithDependency test2 test1
  run ${DRAKY}
  [[ "$status" == 1 ]]
  [[ "$output" == *"cycle"* ]]
  [[ "$output" == *"test1"* ]]
  [[ "$output" == *"test2"* ]]
}

@test "Build compose" {
  _initialize_test_environment
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    image: php-image
EOF
  run ${DRAKY} env build
  [[ "$status" == 0 ]]
  [ -f "${COMPOSE_PATH}" ]
  grep -q "image: php-image" "$COMPOSE_PATH"
}

@test "Build compose: docker-compose.yml file is marked as autogenerated by a comment" {
  _initialize_test_environment
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    image: php-image
EOF
  "${DRAKY}" env build
  run cat $ENV_PATH/docker-compose.yml
  [[ "$output" == *"# This file is autogenerated"* ]]
}

@test "Build compose: import service from an external file" {
  _initialize_test_environment
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
services:
  php:
    image: php-image
EOF
  ${DRAKY} env build
  grep -q "image: php-image" "$COMPOSE_PATH"
}

@test "Build compose: volume paths are converted" {
  _initialize_test_environment
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
services:
  php:
    image: php-image
    volumes:
      - ./test-volume:/test-volume
      - type: volume
        source: ./test-2-volume
        target: /test-2-volume
EOF
  ${DRAKY} env build
  grep -q "../../services/php/./test-volume" "$COMPOSE_PATH"
  # Test if dict volume definitions are also handled correctly.
  grep -q "source: ../../services/php/./test-2-volume" "$COMPOSE_PATH"
}

@test "Build compose: dockerfile paths are converted" {
  _initialize_test_environment
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
services:
  php:
    image: php-image
    build:
      dockerfile: .
EOF
  ${DRAKY} env build
  grep -q "../../services/php/." "$COMPOSE_PATH"
}

@test "Build compose: named volumes are not converted" {
  _initialize_test_environment
  NAMED_VOLUME_1=named_volume
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
volumes:
  ${NAMED_VOLUME_1}:
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
services:
  php:
    image: php-image
    volumes:
      - ${NAMED_VOLUME_1}:/test-volume
EOF
  ${DRAKY} env build
  grep -q -- "- $NAMED_VOLUME_1:" "$COMPOSE_PATH"
}

@test "Build compose: named volumes are carried over from the extended files" {
  _initialize_test_environment
  NAMED_VOLUME_1=named_volume
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
services:
  php:
    image: php-image
    volumes:
      - ${NAMED_VOLUME_1}:/test-volume
volumes:
  ${NAMED_VOLUME_1}:
EOF
  ${DRAKY} env build
  grep -q -- "- $NAMED_VOLUME_1:" "$COMPOSE_PATH"
}

@test "Build compose: the highest version is carried over from the extended files" {
  _initialize_test_environment
  NAMED_VOLUME_1=named_volume
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
  nginx:
    extends:
      file: ../../services/nginx/services.yml
      service: nginx
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
version: '3.4'
services:
  php:
    image: php-image
EOF
  NGINX_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/nginx"
  mkdir -p ${NGINX_SERVICE_PATH}
  # Create an external service file.
  cat > "${NGINX_SERVICE_PATH}/services.yml" << EOF
version: '3.1'
services:
  nginx:
    image: nginx-image
EOF

  ${DRAKY} env build
  grep -q -- "version: '3.4'" "$COMPOSE_PATH"
}

@test "Build compose: variable substitution flag" {
  _initialize_test_environment
  # Create the recipe.
  # Note that we are escaping the variable, so it won't get substituted by bash.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    image: "\${PHP_IMAGE_TEST}"
EOF
  # Give variable a value.
  cat > "${TEST_PROJECT_PATH}/.draky/variables.dk.yml" << EOF
variables:
  PHP_IMAGE_TEST: php-image
EOF
  ${DRAKY} env build -s
  grep -q "image: php-image" "$COMPOSE_PATH"
}

@test "Build compose: 'draky' property is removed from services" {
  _initialize_test_environment
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    image: test-image
    draky:
      addons: []

EOF
  ${DRAKY} env build
  run ! grep -q "draky:" "$COMPOSE_PATH"
}

@test "Addons: Addons can alter services" {
  _initialize_test_environment

  # Create a test addon.
  ADDON_PATH="${TEST_PROJECT_PATH}/.draky/addons/test-addon"
  mkdir -p "$ADDON_PATH"
  # Create the addon config file.
  cat > "${ADDON_PATH}/test-addon.addon.dk.yml" << EOF
id: test-addon
EOF

  ENTRYPOINT_SCRIPT=/test-addon.entrypoint.sh

  cat > "${ADDON_PATH}/hooks.py" << EOF
def alter_service(name: str, service: dict, utils: object, addon: dict):
    service['entrypoint'] = ['$ENTRYPOINT_SCRIPT']
EOF

  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    image: test-image
    draky:
      addons:
        - test-addon
EOF

  ${DRAKY} env build
  grep -q "$ENTRYPOINT_SCRIPT" "$COMPOSE_PATH"
}

@test "Addons: Addons can alter services even if they are enabled on services being extended" {
  _initialize_test_environment

  # Create a test addon.
  ADDON_NAME=test-addon
  ADDON_PATH="${TEST_PROJECT_PATH}/.draky/addons/${ADDON_NAME}"
  ENTRYPOINT_SCRIPT=/test-entrypoint.sh
  mkdir -p "$ADDON_PATH"
  # Create the addon config file.
  cat > "${ADDON_PATH}/${ADDON_NAME}.addon.dk.yml" << EOF
id: ${ADDON_NAME}
EOF
  cat > "${ADDON_PATH}/hooks.py" << EOF
def alter_service(name: str, service: dict, utils: object, addon: dict):
    service['entrypoint'] = ['$ENTRYPOINT_SCRIPT']
EOF

  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
services:
  php:
    image: php-image
    draky:
      addons:
        - ${ADDON_NAME}
EOF
  ${DRAKY} env build
  grep -q "${ENTRYPOINT_SCRIPT}" "$COMPOSE_PATH"
}

@test "Custom commands: Custom command is added to the help" {
  _initialize_test_environment
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/testcommand.dk.sh"
    cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
EOF
  ${DRAKY} env up
  ${DRAKY} -h | grep -q testcommand
}

@test "Custom commands: User can run custom scripts in services" {
  _initialize_test_environment

  TEST_SERVICE=test_service

    # Create the compose file.
  cat > "$COMPOSE_PATH" << EOF
services:
  $TEST_SERVICE:
    image: ghcr.io/draky-dev/draky-generic-testing-environment:1.0.0
    command: 'tail -f /dev/null'
EOF

  TEST_SERVICE_COMMAND_NAME="testservicecommand"
  TEST_SERVICE_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/${TEST_SERVICE_COMMAND_NAME}.${TEST_SERVICE}.dk.sh"
  TEST_SERVICE_COMMAND_MESSAGE="test command inside the service has been executed"

  cat > "${TEST_SERVICE_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
echo "${TEST_SERVICE_COMMAND_MESSAGE}"
EOF
  chmod a+x "${TEST_SERVICE_COMMAND_PATH}"

  ${DRAKY} env up

  # Test command running inside the service
  ${DRAKY} -h | grep -q ${TEST_SERVICE_COMMAND_NAME}
  run ${DRAKY} ${TEST_SERVICE_COMMAND_NAME}
  [[ "$output" == *"${TEST_SERVICE_COMMAND_MESSAGE}"* ]]
}

@test "Custom commands: User can run custom scripts on the host" {
  _initialize_test_environment

  # We need the compose file for draky to work.
  cat > "$COMPOSE_PATH" << EOF
services:
  test:
    image: ghcr.io/draky-dev/draky-generic-testing-environment:1.0.0
    command: 'tail -f /dev/null'
EOF

  HOST_FILE=$HOST_STORAGE_PATH/file
    # Create the compose file.
  TEST_COMMAND_NAME="testcommand"
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/$TEST_COMMAND_NAME.dk.sh"
  TEST_COMMAND_MESSAGE="test command has been executed"

  cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
echo "\$@"
echo "${TEST_COMMAND_MESSAGE}"
touch $HOST_FILE
EOF
  chmod a+x "${TEST_COMMAND_PATH}"

  ARGUMENT=argument1
  # Test command running on the host
  ${DRAKY} -h | grep -q ${TEST_COMMAND_NAME}
  run ${DRAKY} ${TEST_COMMAND_NAME} ${ARGUMENT}
  # Make sure that draky-scoped arguments are not passed to the command.
  [[ "$output" =~ ^${ARGUMENT} ]]
  [[ "$output" == *"${TEST_COMMAND_MESSAGE}"* ]]
  # Make sure that the file created has been created on the host.
  [[ -f $HOST_FILE ]]
}

@test "Custom commands: Environmental variables are getting passed to the custom command run on host" {
    _initialize_test_environment
  TEST_COMMAND_NAME="testcommand"
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/$TEST_COMMAND_NAME.dk.sh"

  cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
env
EOF
  chmod a+x "${TEST_COMMAND_PATH}"

  SOME_VARIABLE_VALUE="some value"
  # Set custom variable.
  cat > "${TEST_PROJECT_PATH}/.draky/variables.dk.yml" << EOF
variables:
  SOME_VARIABLE: '$SOME_VARIABLE_VALUE'
EOF

  run "${DRAKY}" "${TEST_COMMAND_NAME}"
  # Make sure that variables don't have quotes included.
  [[ "$output" != *"DRAKY_VERSION=\""* ]]
  [[ "$output" == *"${SOME_VARIABLE_VALUE}"* ]]
}

@test "Custom commands: Passthrough exit code to the host" {
  _initialize_test_environment

  TEST_SERVICE=test_service

    # Create the compose file.
  cat > "$COMPOSE_PATH" << EOF
services:
  $TEST_SERVICE:
    image: ghcr.io/draky-dev/draky-generic-testing-environment:1.0.0
    command: 'tail -f /dev/null'
EOF
  TEST_COMMAND_NAME="testcommand"
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/$TEST_COMMAND_NAME.dk.sh"
  ERROR_CODE=11

  cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
exit $ERROR_CODE
EOF
  chmod a+x "${TEST_COMMAND_PATH}"

  TEST_SERVICE_COMMAND_NAME="testservicecommand"
  TEST_SERVICE_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/${TEST_SERVICE_COMMAND_NAME}.${TEST_SERVICE}.dk.sh"

  cat > "${TEST_SERVICE_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
exit $ERROR_CODE
EOF
  chmod a+x "${TEST_SERVICE_COMMAND_PATH}"

  ${DRAKY} env up

  # Test command running on the host
  ${DRAKY} -h | grep -q ${TEST_COMMAND_NAME}
  run ${DRAKY} ${TEST_COMMAND_NAME}
  [[ "$status" == "${ERROR_CODE}" ]]

  # Test command running inside the service
  ${DRAKY} -h | grep -q ${TEST_SERVICE_COMMAND_NAME}
  run ${DRAKY} ${TEST_SERVICE_COMMAND_NAME}
  [[ "$status" == "${ERROR_CODE}" ]]
}

@test "Custom commands: Custom scripts are running in tty" {
  _initialize_test_environment

  TEST_SERVICE=test_service

    # Create the compose file.
  cat > "$COMPOSE_PATH" << EOF
services:
  $TEST_SERVICE:
    image: ghcr.io/draky-dev/draky-generic-testing-environment:1.0.0
    command: 'tail -f /dev/null'
EOF
  TEST_COMMAND_NAME="testcommand"
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/$TEST_COMMAND_NAME.dk.sh"
  TEST_COMMAND_MESSAGE="we are running command on host in terminal"

  cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
if [ -t 0 ]; then
  echo "${TEST_COMMAND_MESSAGE}"
fi
EOF
  chmod a+x "${TEST_COMMAND_PATH}"

  TEST_SERVICE_COMMAND_NAME="testservicecommand"
  TEST_SERVICE_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/${TEST_SERVICE_COMMAND_NAME}.${TEST_SERVICE}.dk.sh"
  TEST_SERVICE_COMMAND_MESSAGE="we are running command in service in terminal"

  cat > "${TEST_SERVICE_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
if [ -t 0 ]; then
  echo "${TEST_SERVICE_COMMAND_MESSAGE}"
fi
EOF
  chmod a+x "${TEST_SERVICE_COMMAND_PATH}"

  ${DRAKY} env up

  run ${DRAKY} ${TEST_COMMAND_NAME}
  [[ "$output" == *"${TEST_COMMAND_MESSAGE}"* ]]

  run ${DRAKY} ${TEST_SERVICE_COMMAND_NAME}
  [[ "$output" == *"${TEST_SERVICE_COMMAND_MESSAGE}"* ]]
}

@test "Custom commands: Custom scripts can receive data from stdin" {
  _initialize_test_environment

  TEST_SERVICE=test_service

    # Create the compose file.
  cat > "$COMPOSE_PATH" << EOF
services:
  $TEST_SERVICE:
    image: ghcr.io/draky-dev/draky-generic-testing-environment:1.0.0
    command: 'tail -f /dev/null'
EOF
  TEST_COMMAND_NAME="testcommand"
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/$TEST_COMMAND_NAME.dk.sh"
  TEST_COMMAND_STDIN_DATA="stdin data passed to the command running on the host"
  TEST_COMMAND_MESSAGE="we are not in a terminal when using stdin to pass data to the command running on host"

  cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
if [ ! -t 0 ]; then
  echo "${TEST_COMMAND_MESSAGE}"
fi
while read line
do
  echo "\$line"
done < /dev/stdin
EOF
  chmod a+x "${TEST_COMMAND_PATH}"

  TEST_SERVICE_COMMAND_NAME="testservicecommand"
  TEST_SERVICE_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/${TEST_SERVICE_COMMAND_NAME}.${TEST_SERVICE}.dk.sh"
  TEST_SERVICE_COMMAND_STDIN_DATA="stdin data passed to the command running inside the service"
  TEST_SERVICE_COMMAND_MESSAGE="we are not in a terminal when using stdin to pass data to the command running in a service"

  cat > "${TEST_SERVICE_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
if [ ! -t 0 ]; then
  echo "${TEST_SERVICE_COMMAND_MESSAGE}"
fi
while read line
do
  echo "\$line"
done < /dev/stdin
EOF
  chmod a+x "${TEST_SERVICE_COMMAND_PATH}"

  ${DRAKY} env up

  run bash -c "echo \"${TEST_COMMAND_STDIN_DATA}\" | ${DRAKY} ${TEST_COMMAND_NAME}"
  [[ "$output" == *"${TEST_COMMAND_MESSAGE}"* ]]
  [[ "$output" == *"${TEST_COMMAND_STDIN_DATA}"* ]]
  run bash -c "echo \"${TEST_SERVICE_COMMAND_STDIN_DATA}\" | ${DRAKY} ${TEST_SERVICE_COMMAND_NAME}"
  [[ "$output" == *"${TEST_SERVICE_COMMAND_MESSAGE}"* ]]
  [[ "$output" == *"${TEST_SERVICE_COMMAND_STDIN_DATA}"* ]]
}

@test "Custom commands: command is run inside the container as a specified user by id" {
  _initialize_test_environment
  TEST_SERVICE=test_service
  USER_ID=1100
    # Create the compose file.
  cat > "$COMPOSE_PATH" << EOF
services:
  $TEST_SERVICE:
    image: ghcr.io/draky-dev/draky-generic-testing-environment:1.0.0
    command: 'tail -f /dev/null'
EOF
  TEST_COMMAND_NAME="testcommand"
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/$TEST_COMMAND_NAME.$TEST_SERVICE.dk.sh"
  TEST_COMMAND_COMPANION_PATH="${TEST_COMMAND_PATH}.yml"

  cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
id -u
EOF
  chmod a+x "${TEST_COMMAND_PATH}"

  cat > "${TEST_COMMAND_COMPANION_PATH}" << EOF
user: ${USER_ID}
EOF

  ${DRAKY} env up
  run "${DRAKY}" "${TEST_COMMAND_NAME}"
  [[ "$output" == *"${USER_ID}"* ]]
}

@test "Custom commands: command is run inside the container as a specified user by name" {
  _initialize_test_environment
  TEST_SERVICE=test_service
  USER=bin
    # Create the compose file.
  cat > "$COMPOSE_PATH" << EOF
services:
  $TEST_SERVICE:
    image: ghcr.io/draky-dev/draky-generic-testing-environment:1.0.0
    command: 'tail -f /dev/null'
EOF
  TEST_COMMAND_NAME="testcommand"
  TEST_COMMAND_PATH="${TEST_PROJECT_PATH}/.draky/$TEST_COMMAND_NAME.$TEST_SERVICE.dk.sh"
  TEST_COMMAND_COMPANION_PATH="${TEST_COMMAND_PATH}.yml"

  cat > "${TEST_COMMAND_PATH}" << EOF
#!/usr/bin/env sh
id
EOF
  chmod a+x "${TEST_COMMAND_PATH}"

  cat > "${TEST_COMMAND_COMPANION_PATH}" << EOF
user: ${USER}
EOF

  ${DRAKY} env up
  run "${DRAKY}" "${TEST_COMMAND_NAME}"
  echo "$output"
  [[ "$output" == *"${USER}"* ]]
}

@test "Service building from dockerfile." {
  _initialize_test_environment
  DOCKER_CACHE_PATH=/.docker
  # Docker cache directory exists.
  docker exec draky bash -c "[ -d $DOCKER_CACHE_PATH ]"
  # Docker cache directory is owned by the host user.
  [[ "$(docker exec draky bash -c "stat -c %u $DOCKER_CACHE_PATH")" == "${UID}" ]]
  SERVICE_NAME='test'

  cat > "$COMPOSE_PATH" << EOF
services:
  ${SERVICE_NAME}:
    build:
      dockerfile: ./Dockerfile
EOF

  cat > "$(dirname "$COMPOSE_PATH")/Dockerfile" << EOF
FROM alpine
HEALTHCHECK --interval=1s --retries=1 --timeout=1s CMD exit 0'
CMD sleep 100
EOF
  # If this returns no errors it means that dockerfile build has completed succesfully.
  ${DRAKY} env up
  ${DRAKY} env down
}

@test "Build paths are converted" {
    _initialize_test_environment
  # Create the recipe.
  cat > "$RECIPE_PATH" << EOF
services:
  php:
    extends:
      file: ../../services/php/services.yml
      service: php
EOF
  PHP_SERVICE_PATH="${TEST_PROJECT_PATH}/.draky/services/php"
  mkdir -p ${PHP_SERVICE_PATH}
  # Create an external service file.
  cat > "${PHP_SERVICE_PATH}/services.yml" << EOF
services:
  php:
    image: php-image
    build:
      context: ./context
      dockerfile: ./Dockerfile
EOF
  ${DRAKY} env build
  grep -q "../../services/php/./Dockerfile" "$COMPOSE_PATH"
  # Test if dict volume definitions are also handled correctly.
  grep -q "../../services/php/./context" "$COMPOSE_PATH"
}
